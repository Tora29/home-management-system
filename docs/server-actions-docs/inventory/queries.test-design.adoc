= getMasterDataクエリ関数 設計書
:toc: left
:toclevels: 3
:sectnums:
:icons: font
:source-highlighter: rouge

== 概要

本ドキュメントは、在庫管理システムにおける`getMasterData`クエリ関数の詳細設計書である。
この関数は、システム内で使用されるマスターデータ（カテゴリ、単位、保管場所）を効率的に一括取得するためのクエリ層の実装を定義している。

=== 対象読者

* 開発者（実装・保守担当）
* システムアーキテクト
* QAエンジニア
* プロジェクトマネージャー

=== スコープと範囲

* 対象ファイル: `src/features/inventory/api/queries.ts`
* テストファイル: `src/features/inventory/api/queries.test.ts`
* 機能範囲: マスターデータの並列取得処理
* アーキテクチャ層: Features層（FSD準拠）

== 背景と動機

=== 必要性

在庫管理機能において、商品登録や編集時に必要となる選択肢データ（カテゴリ、単位、保管場所）を効率的に取得する必要がある。これらのデータは頻繁に参照されるが、更新頻度は低いマスターデータである。

=== 解決しようとしている問題

* 複数のマスターテーブルへの逐次的なアクセスによるパフォーマンス低下
* UIコンポーネントから直接データベースアクセスすることによる責任の混在
* 非アクティブなマスターデータを含めた不要なデータの取得

=== ビジネス要件

* フォーム画面のロード時に必要な全選択肢を高速に取得
* アクティブなマスターデータのみを表示
* データの表示順序を制御（sortOrderによる並び替え）

=== 技術的要件

* 並列処理による高速化（Promise.all使用）
* 型安全性の確保（TypeScript）
* Feature-Sliced Design (FSD)アーキテクチャへの準拠

== アーキテクチャ/構造

=== 全体的な構成

[source]
----
app層
  ↓ データ取得要求
features/inventory/api/queries.ts (getMasterData)
  ↓ 並列クエリ実行
shared/lib/prisma.ts (Prismaクライアント)
  ↓ SQL実行
PostgreSQL Database (Category, Unit, Location テーブル)
----

=== 主要なコンポーネント

==== getMasterData関数

* **責務**: 3つのマスターテーブルからアクティブなデータを並列取得
* **配置**: `features/inventory/api/queries.ts`
* **アーキテクチャ層**: Features層

==== Prismaクライアント

* **責務**: データベースアクセスの抽象化
* **配置**: `shared/lib/prisma.ts`
* **アーキテクチャ層**: Shared層

=== 依存関係とその理由

[source,typescript]
----
import { prisma } from '@/shared/lib/prisma'  // Shared層からのインポート（FSD準拠）
import type { Category, Unit, Location } from '@/entities/inventory/model'  // Entities層からの型定義
----

* **Prismaクライアント**: データベースアクセスのため
* **エンティティ型定義**: 型安全性の確保のため

== 詳細設計

=== 関数シグネチャ

[source,typescript]
----
export async function getMasterData(): Promise<{
  categories: Category[]
  units: Unit[]
  locations: Location[]
}>
----

=== 入力パラメータ

なし（固定条件でのクエリ実行）

=== 出力仕様

|===
|プロパティ |型 |説明

|categories
|Category[]
|アクティブなカテゴリの配列（sortOrder順）

|units
|Unit[]
|アクティブな単位の配列（sortOrder順）

|locations
|Location[]
|アクティブな保管場所の配列（sortOrder順）
|===

=== クエリ条件

全てのクエリで共通:
* `where: { isActive: true }` - アクティブなレコードのみ取得
* `orderBy: { sortOrder: 'asc' }` - 表示順序で昇順ソート

=== 並列処理の仕組み

[source,typescript]
----
const [categories, units, locations] = await Promise.all([
  // 3つのクエリが同時に実行される
  prisma.category.findMany(...),
  prisma.unit.findMany(...),
  prisma.location.findMany(...)
])
----

== 実装ガイドライン

=== ベストプラクティス

. **並列処理の活用**: Promise.allを使用して複数クエリを同時実行
. **型安全性の確保**: TypeScriptの型定義を活用
. **FSDアーキテクチャ準拠**: Features層に配置し、適切な層からのインポート
. **シンプルな実装**: 複雑なロジックを避け、読みやすさを優先

=== 制約事項と前提条件

==== 前提条件

* Prismaクライアントが正しく初期化されている
* データベース接続が確立されている
* マスターテーブルが存在し、適切なスキーマが定義されている

==== 制約事項

* 非アクティブなデータは取得しない
* ソート順はsortOrderフィールドのみで決定
* キャッシュ機構は実装しない（RSCで自動キャッシュ）

=== 注意点とアンチパターン

==== 避けるべきパターン

* 逐次的なクエリ実行（await を個別に使用）
* クライアントサイドでのフィルタリング
* 過度な最適化（例：不要なselect句の追加）

==== 推奨パターン

* Promise.allによる並列実行
* データベースレベルでのフィルタリング
* シンプルで読みやすいコード

== 実装詳細

=== アルゴリズムとロジック

. Promise.allで3つのクエリを同時に開始
. 各クエリは独立して実行される
. 全てのクエリが完了するまで待機
. 結果をオブジェクトにまとめて返却

=== エラーハンドリング戦略

==== エラー伝播

* いずれかのクエリでエラーが発生した場合、Promise.allが即座に拒否される
* エラーはそのまま上位層に伝播される
* 呼び出し元でキャッチして適切に処理する設計

==== エラーの種類

|===
|エラー種別 |発生条件 |対処法

|データベース接続エラー
|DBサーバーへの接続失敗
|リトライまたはエラー画面表示

|テーブルアクセスエラー
|権限不足、テーブル不存在
|システム管理者への通知

|タイムアウトエラー
|クエリ実行時間超過
|クエリ最適化またはタイムアウト延長
|===

=== リトライとフォールバック機構

現在の実装ではリトライ機構は含まれていない。必要に応じて上位層で実装することを推奨。

== 使用例

=== 典型的な使用パターン

[source,typescript]
----
// RSC（React Server Component）での使用例
async function InventoryFormPage() {
  const masterData = await getMasterData()

  return (
    <InventoryForm
      categories={masterData.categories}
      units={masterData.units}
      locations={masterData.locations}
    />
  )
}
----

=== サーバーアクションでの使用例

[source,typescript]
----
// バリデーション時の使用
export async function validateInventoryData(data: unknown) {
  const masterData = await getMasterData()

  // カテゴリIDの妥当性チェック
  const validCategoryIds = masterData.categories.map(c => c.id)
  if (!validCategoryIds.includes(data.categoryId)) {
    throw new Error('無効なカテゴリが選択されました')
  }
  // ...
}
----

== テスト仕様と検証

=== テストから抽出した仕様

==== 正常系テストケース

[cols="2,3,2"]
|===
|テストケース |期待される動作 |検証内容

|全マスターデータの取得
|3種類のマスターデータが正しく取得される
|返却オブジェクトの構造と内容

|空の結果での動作
|空配列でも正常に処理される
|エラーが発生しないこと

|並列処理の実行
|3つのクエリが同時に実行される
|実行時間が最長クエリ時間程度
|===

==== 異常系テストケース

[cols="2,3,2"]
|===
|テストケース |期待される動作 |検証内容

|カテゴリ取得エラー
|エラーが伝播される
|エラーメッセージの確認

|単位取得エラー
|エラーが伝播される
|エラーメッセージの確認

|場所取得エラー
|エラーが伝播される
|エラーメッセージの確認

|複数クエリでのエラー
|最初のエラーが伝播される
|Promise.allの動作確認
|===

=== パフォーマンステスト

==== 並列実行の検証

テストでは、3つのクエリが並列に実行されることを以下の方法で検証：

. 各クエリの開始・終了タイミングを記録
. 全てのクエリが開始してから最初のクエリが終了することを確認
. 総実行時間が最長クエリ時間程度であることを確認

=== カバレッジと品質基準

* ステートメントカバレッジ: 100%
* ブランチカバレッジ: 100%（条件分岐なし）
* 関数カバレッジ: 100%

=== 境界値テストとエッジケース

|===
|ケース |テスト内容 |期待結果

|空のテーブル
|全てのテーブルが空の場合
|空配列を含むオブジェクトが返される

|大量データ
|各テーブルに1000件以上のデータ
|メモリエラーなく処理完了

|NULLフィールド
|descriptionがNULLの場合
|正常に処理される
|===

== デプロイメントと運用

=== デプロイ手順

. 環境変数の設定（DATABASE_URL）
. Prismaマイグレーションの実行
. マスターデータの初期投入
. アプリケーションのデプロイ

=== 環境設定の要件

==== 必須環境変数

[source,bash]
----
DATABASE_URL="postgresql://user:password@host:port/database"
----

==== 推奨設定

* コネクションプール: 最小5、最大20
* クエリタイムアウト: 30秒
* リトライ回数: 3回（アプリケーション層で実装）

=== モニタリングとログ戦略

==== 監視項目

* クエリ実行時間
* エラー発生率
* データベース接続状態

==== ログ出力

* エラーログ: 全てのデータベースエラー
* パフォーマンスログ: 1秒以上かかるクエリ
* デバッグログ: 開発環境でのクエリ詳細

== メンテナンス

=== トラブルシューティングガイド

==== よくある問題と解決策

[cols="2,2,3"]
|===
|問題 |原因 |解決策

|クエリが遅い
|インデックス不足
|isActiveとsortOrderに複合インデックスを作成

|接続エラー
|接続プール枯渇
|プールサイズを増やす

|メモリ不足
|大量データの一括取得
|ページネーション実装を検討
|===

=== デバッグ手法

[source,typescript]
----
// デバッグログを有効化
const startTime = Date.now()
const result = await getMasterData()
console.log(`Query time: ${Date.now() - startTime}ms`)

// Prismaのクエリログ有効化
const prisma = new PrismaClient({
  log: ['query', 'error', 'warn']
})
----

== セキュリティ考慮事項

=== 認証・認可の仕組み

* 現在の実装では認証チェックなし
* 上位層（RSCまたはサーバーアクション）で認証を実装

=== データ保護とプライバシー

* センシティブデータは含まれない（マスターデータのみ）
* SQLインジェクション: Prismaにより防止

=== 潜在的な脆弱性と対策

|===
|脆弱性 |リスク |対策

|DoS攻撃
|大量リクエストによるDB負荷
|レート制限の実装

|情報漏洩
|非アクティブデータの露出
|whereクローズで確実にフィルタ

|権限昇格
|不正なデータアクセス
|上位層での認可チェック
|===

== パフォーマンス考慮事項

=== パフォーマンス要件

* レスポンスタイム: 200ms以下（通常環境）
* 同時実行数: 100リクエスト/秒
* メモリ使用量: 50MB以下/リクエスト

=== 最適化ポイント

==== データベースレベル

[source,sql]
----
-- 推奨インデックス
CREATE INDEX idx_category_active_sort ON categories(is_active, sort_order);
CREATE INDEX idx_unit_active_sort ON units(is_active, sort_order);
CREATE INDEX idx_location_active_sort ON locations(is_active, sort_order);
----

==== アプリケーションレベル

* RSCの自動キャッシュ活用
* 必要に応じてReact.cacheでメモ化
* CDNキャッシュの活用（静的生成時）

=== スケーラビリティ設計

==== 水平スケーリング

* ステートレスな実装により、複数インスタンスで並列処理可能
* データベースのレプリカ読み取り対応

==== 垂直スケーリング

* マスターデータの増加に対してはインデックス最適化で対応
* 必要に応じてページネーション実装

== 参考資料

=== 関連ドキュメント

* link:../README.md[プロジェクトREADME]
* link:./FSD-ARCHITECTURE-RULES.md[FSDアーキテクチャルール]
* link:https://www.prisma.io/docs[Prisma公式ドキュメント]

=== 外部リソース

* link:https://feature-sliced.design/[Feature-Sliced Design]
* link:https://nextjs.org/docs/app/building-your-application/data-fetching[Next.js Data Fetching]
* link:https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all[Promise.all MDN]

=== コード参照

* 実装: `src/features/inventory/api/queries.ts:13-34`
* テスト: `src/features/inventory/api/queries.test.ts:29-324`
* 型定義: `src/entities/inventory/model/index.ts`

---
_最終更新: 2025年9月_
_ドキュメントバージョン: 1.0.0_