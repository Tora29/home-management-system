= 在庫管理機能 Server Actions 設計書
:toc: left
:toclevels: 3
:sectnums:
:icons: font
:source-highlighter: highlightjs

== 概要

=== ドキュメントの目的
本設計書は、家庭管理システムの在庫管理機能におけるServer Actionsの実装について、その設計と振る舞いを包括的に文書化したものである。特に `createItemAction` の実装詳細、テストケースから抽出された仕様、エラーハンドリング、パフォーマンス考慮事項を明記している。

=== 対象読者
* 開発者
* QAエンジニア
* システムアーキテクト
* プロジェクトマネージャー

=== スコープと範囲
* 在庫アイテム作成機能（`createItemAction`）
* 入力バリデーション機構
* エラーハンドリング戦略
* Next.js App Router環境でのServer Actions実装

== 背景と動機

=== なぜこの機能が必要か
家庭内の在庫管理を効率化し、日用品の在庫切れを防ぎ、適切な在庫量を維持するためのシステムが必要である。Server Actionsを使用することで、フォーム送信をサーバーサイドで安全に処理し、クライアント・サーバー間の通信を最適化する。

=== 解決しようとしている問題
* 家庭内の在庫品の可視化不足
* 手動での在庫管理の煩雑さ
* 在庫切れによる買い忘れ
* 重複購入の防止

=== ビジネス要件や技術的要件
* **ビジネス要件**
  - 在庫アイテムの登録・管理機能
  - カテゴリ別の整理
  - 数量管理と単位設定
  - 保管場所の記録

* **技術的要件**
  - Next.js 15のServer Actions使用
  - TypeScriptによる型安全性の確保
  - Zodによる実行時バリデーション
  - Prismaを使用したデータベースアクセス

== アーキテクチャ/構造

=== 全体的な構成
本機能はFeature-Sliced Design (FSD)アーキテクチャに従い、以下のレイヤー構成となっている：

[source]
----
features/inventory/
├── api/
│   ├── actions.ts      # Server Actions (I/O層)
│   └── actions.test.ts # テストファイル
├── model/
│   └── validators.ts   # Zodバリデーションスキーマ
├── service/
│   └── create-item.ts  # ビジネスロジック層
└── repository/
    └── item.repository.ts # データアクセス層
----

=== 主要なコンポーネント
* **Server Action (actions.ts)**: クライアントからのリクエストを受け取る薄いI/O層
* **Validator (validators.ts)**: 入力データの検証スキーマ定義
* **Service (create-item.ts)**: ビジネスロジックの実装
* **Repository**: Prismaを使用したデータベース操作

=== 依存関係とその理由
* **Next.js**: Server Actions機能の提供元
* **Zod**: 実行時の型検証とエラーメッセージ生成
* **Prisma**: 型安全なデータベースアクセス
* **Vitest**: テスティングフレームワーク

== 詳細設計

=== createItemAction の詳細仕様

==== インターフェース定義
[source,typescript]
----
export async function createItemAction(
  _prevState: {
    success: boolean;
    errors?: Record<string, string>;
    error?: string
  } | null,
  formData: FormData
): Promise<{
  success: boolean;
  errors?: Record<string, string>;
  error?: string
} | never>
----

==== 入力パラメータ
* `_prevState`: 前回の実行結果（React useFormStateフック用）
* `formData`: HTMLフォームから送信されたデータ

==== 処理フロー
1. **入力データの抽出**: FormDataから必要なフィールドを取得
2. **バリデーション**: Zodスキーマによる検証
3. **サービス呼び出し**: `createInventoryItem` の実行
4. **キャッシュ無効化**: 関連ページの再検証
5. **リダイレクト**: 成功時は一覧ページへ遷移

=== バリデーションスキーマ

==== 必須フィールド
[source,typescript]
----
name: z.string().min(1, "アイテム名は必須です")
quantity: z.coerce.number().min(0, "数量は1以上の数値を入力してください")
unit: z.string().min(1, "単位は必須です")
location: z.string().min(1, "保管場所は必須です")
categoryId: z.string().min(1, "カテゴリは必須です")
----

==== オプションフィールド
[source,typescript]
----
description: z.string().optional()
barcode: z.string().optional()
notes: z.string().optional()
----

=== エラーレスポンス形式

==== バリデーションエラー
[source,json]
----
{
  "success": false,
  "errors": {
    "name": "アイテム名は必須です",
    "unit": "単位は必須です",
    "location": "保管場所は必須です",
    "categoryId": "カテゴリは必須です"
  }
}
----

==== システムエラー
[source,json]
----
{
  "success": false,
  "error": "アイテムの登録に失敗しました"
}
----

== 実装ガイドライン

=== ベストプラクティス
* Server Actionsには `'use server'` ディレクティブを必須とする
* 入力データは必ずバリデーションを実施
* エラーハンドリングは包括的に実装
* Next.jsのリダイレクトエラーは必ず再スローする
* キャッシュの無効化を適切に実施

=== 制約事項と前提条件
* Server ActionsはPOSTメソッドのみサポート
* FormDataオブジェクトとして入力を受け取る
* クライアントコンポーネントから直接呼び出し不可

=== 注意点とアンチパターン
* バリデーションをクライアント側のみに依存しない
* ビジネスロジックをServer Action内に直接記述しない
* エラーメッセージに機密情報を含めない

== 実装詳細

=== アルゴリズムとロジック

==== FormDataの変換処理
[source,typescript]
----
const rawInput = Object.fromEntries(formData.entries())
const validatedData = createItemSchema.parse({
  name: String(rawInput.name || ''),
  description: rawInput.description ? String(rawInput.description) : undefined,
  quantity: rawInput.quantity,
  unit: String(rawInput.unit || ''),
  location: String(rawInput.location || ''),
  barcode: rawInput.barcode ? String(rawInput.barcode) : undefined,
  notes: rawInput.notes ? String(rawInput.notes) : undefined,
  categoryId: String(rawInput.categoryId || ''),
})
----

=== エラーハンドリング戦略

==== エラーハンドリングの優先順位
1. **Zodバリデーションエラー**: フィールド別エラーメッセージを返す
2. **Next.jsリダイレクトエラー**: 必ず再スローする
3. **ビジネスエラー**: エラーメッセージを返す
4. **予期しないエラー**: デフォルトメッセージを返す

==== エラー処理の実装
[source,typescript]
----
catch (error) {
  if (error instanceof ZodError) {
    // バリデーションエラーの処理
    const errors: Record<string, string> = {}
    error.issues.forEach((issue) => {
      if (issue.path[0]) {
        errors[issue.path[0].toString()] = issue.message
      }
    })
    return { success: false, errors }
  }

  if (isRedirectError(error)) {
    // リダイレクトエラーは再スロー
    throw error
  }

  if (error instanceof Error) {
    // ビジネスエラー
    return { success: false, error: error.message }
  }

  // 予期しないエラー
  return { success: false, error: ITEM_ERROR.CREATE_FAILED }
}
----

== 使用例

=== 典型的な使用パターン

==== フォームコンポーネントでの実装
[source,tsx]
----
import { useFormState } from 'react-dom'
import { createItemAction } from '@/features/inventory/api/actions'

function ItemForm() {
  const [state, formAction] = useFormState(createItemAction, null)

  return (
    <form action={formAction}>
      <input name="name" required />
      <input name="quantity" type="number" required />
      <input name="unit" required />
      <input name="location" required />
      <select name="categoryId" required>
        <option value="category-1">カテゴリ1</option>
      </select>
      <button type="submit">登録</button>
    </form>
  )
}
----

=== サンプルデータ

==== 正常系の入力例
[source]
----
name: "トイレットペーパー"
description: "12ロール入り"
quantity: "5"
unit: "パック"
location: "倉庫A"
barcode: "4901234567890"
notes: "特売時に購入"
categoryId: "category-1"
----

==== エッジケースの入力例
[source]
----
name: "在庫ゼロアイテム"
quantity: "0"  // 0も許容される
unit: "個"
location: "倉庫B"
categoryId: "category-2"
// オプション項目は省略可能
----

== テスト仕様と検証

=== テストケースから抽出した仕様

==== 正常系テストケース
1. **完全なデータでの作成**
   - すべてのフィールドが入力された場合の正常処理
   - サービス層の呼び出し確認
   - キャッシュ無効化の確認
   - リダイレクト処理の確認

2. **最小限のデータでの作成**
   - 必須フィールドのみでの正常処理
   - オプションフィールドは`undefined`として処理

==== 異常系テストケース
1. **バリデーションエラー**
   - 必須フィールドの不足
   - 不正な数値形式
   - 負の数量値

2. **サービス層エラー**
   - データベース接続エラー
   - 予期しないエラー

==== エッジケース
1. **空のFormData処理**
   - すべてのフィールドでエラーメッセージ返却

2. **数量ゼロの処理**
   - 0は有効な値として処理

3. **prevStateの存在確認**
   - prevStateの有無に関わらず正常動作

=== カバレッジと品質基準
* ステートメントカバレッジ: 100%
* ブランチカバレッジ: 100%
* エラーパスの網羅的テスト実施

=== 境界値テストとエッジケース
* 数量の境界値: 0（最小値）、Number.MAX_SAFE_INTEGER（最大値）
* 文字列長: 空文字列、最大長文字列
* FormData: 空、必須項目のみ、全項目入力

== デプロイメントと運用

=== デプロイ手順
1. 環境変数の設定確認
2. データベースマイグレーションの実行
3. ビルドとテストの実行
4. 本番環境へのデプロイ

=== 環境設定の要件
* Node.js: v18以上
* Next.js: v15以上
* データベース: PostgreSQL（Vercel Postgres）

=== モニタリングとログ戦略
* Server Actionsの実行時間監視
* エラー発生率の追跡
* バリデーションエラーの傾向分析

== メンテナンス

=== トラブルシューティングガイド

==== よくある問題と解決策
1. **NEXT_REDIRECTエラー**
   - 原因: リダイレクトエラーが適切に処理されていない
   - 解決: `isRedirectError`チェックと再スローの実装

2. **バリデーションエラーが表示されない**
   - 原因: エラーオブジェクトの構造が不正
   - 解決: エラーレスポンス形式の確認

3. **フォーム送信後のキャッシュ更新されない**
   - 原因: `revalidatePath`の呼び出し漏れ
   - 解決: 必要なパスすべてに対して再検証を実行

=== デバッグ手法
* Server Action内でのconsole.log使用
* Next.jsデバッグモードの活用
* ネットワークタブでのリクエスト/レスポンス確認

== セキュリティ考慮事項

=== 認証・認可の仕組み
* 現在の実装では認証機能は未実装
* 今後、ユーザー認証とロールベースアクセス制御の実装を検討

=== データ保護とプライバシー
* 入力データのサニタイゼーション実施
* SQLインジェクション対策（Prismaによる自動エスケープ）
* XSS対策（React/Next.jsによる自動エスケープ）

=== 潜在的な脆弱性と対策
* **CSRF攻撃**: Next.jsのServer Actionsは自動的にCSRF保護を提供
* **入力値の改竄**: サーバーサイドバリデーションで対処
* **大量リクエスト**: レート制限の実装を検討

== パフォーマンス考慮事項

=== パフォーマンス要件
* Server Action実行時間: 500ms以内
* データベースクエリ: 100ms以内
* フォーム送信からレスポンスまで: 1秒以内

=== 最適化ポイント
* FormDataの処理を最小限に
* データベースクエリの最適化
* キャッシュ戦略の活用

=== スケーラビリティ設計
* データベース接続プールの適切な設定
* Server Actionsの並列実行制御
* エッジコンピューティングの活用検討

== 参考資料

=== 関連ドキュメント
* link:https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations[Next.js Server Actions公式ドキュメント]
* link:https://zod.dev/[Zod公式ドキュメント]
* link:https://www.prisma.io/docs[Prisma公式ドキュメント]

=== 外部リソース
* Feature-Sliced Design公式サイト
* React Hook Form with Server Actions
* Next.js App Routerベストプラクティス

=== プロジェクト内部文書
* `/docs/architecture/FSD-ARCHITECTURE-RULES.md`
* `/CLAUDE.md` - プロジェクト規約
* `/docs/api/` - API仕様書